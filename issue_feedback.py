import os
from dotenv import load_dotenv
from openai import OpenAI

# Load environment variables from .env file
load_dotenv()

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

class Issue:
    """
    Represents an issue with a current state (title and body) along with
    proposed state fields. (The proposed states are used only for revision proposals.)
    """
    def __init__(self, issue_id, issue_title, issue_body):
        self.issue_id = issue_id
        self.issue_title = issue_title            # Current title
        self.issue_body = issue_body              # Current body
        # For update proposals generated by LLM.
        self.proposed_issue_title = None          
        self.proposed_issue_body = None           

    def __str__(self):
        return (f"Issue ID: {self.issue_id}\n"
                f"Title: {self.issue_title}\n"
                f"Body: {self.issue_body}\n")

def parse_generated_issues(raw_output):
    """
    Parses the raw_output (string) returned by the initial issue generation process
    into a list of Issue objects.
    
    Expected format (as generated by the LLM):
    
      Issue 1: <Issue Title>
      <Issue body text...>
      Issue 2: <Issue Title>
      <Issue body text...>
    
    This basic parser can be adapted to more robust approaches.
    """
    issues = []
    lines = raw_output.splitlines()
    issue_id = 1
    current_title = None
    current_body = ""
    for line in lines:
        if not line.strip():
            continue
        # Look for the beginning of a new issue.
        if line.startswith("Issue"):
            # If there's a current issue in progress, append it.
            if current_title is not None:
                issues.append(Issue(issue_id, current_title, current_body.strip()))
                issue_id += 1
                current_body = ""
            # Expecting format "Issue <ID>: <Title>" (we ignore the number provided by the LLM)
            parts = line.split(":", 1)
            if len(parts) == 2:
                current_title = parts[1].strip()
            else:
                current_title = line.strip()
        else:
            current_body += line + "\n"
    # Append the final issue
    if current_title is not None:
        issues.append(Issue(issue_id, current_title, current_body.strip()))
    return issues

def parse_proposals(raw_output):
    """
    Parses the LLM output that contains proposals for each existing issue and suggestions for new issues.
    
    Expected output format:
    
    For existing issues:
    ---------------------
    Issue <ID>:
    Action: <Update/Delete>
    If Action is Update, then include:
    Proposed Title: <revised title>
    Proposed Body:
    <revised description>
    
    For new issues:
    ---------------------
    New Issue:
    Proposed Title: <title>
    Proposed Body:
    <description>
    
    Returns a tuple:
       (modifications, new_proposals)
       
       modifications is a dict mapping issue_id (int) to a dict:
           { "action": "Update" or "Delete",
             "proposed_title": <value> (for Update),
             "proposed_body": <value> (for Update) }
             
       new_proposals is a list of dicts, each with keys:
           { "proposed_title": <value>, "proposed_body": <value> }
    """
    modifications = {}
    new_proposals = []
    
    # Split the response into paragraphs (blocks separated by blank lines)
    blocks = [block.strip() for block in raw_output.split("\n\n") if block.strip()]
    
    for block in blocks:
        lines = block.splitlines()
        if not lines:
            continue
        header = lines[0].strip()
        if header.startswith("Issue"):
            # Parse an existing issue block.
            try:
                # Extract issue id. Expected header format "Issue <ID>:"
                issue_id = int(header.split()[1].replace(":", ""))
            except Exception as e:
                print("Error parsing issue id in proposal:", e)
                continue
            action = None
            proposed_title = None
            proposed_body_lines = []
            for idx, raw_line in enumerate(lines[1:], start=1):
                line = raw_line.strip()
                if line.startswith("Action:"):
                    action = line.split("Action:")[1].strip()
                elif line.startswith("Proposed Title:"):
                    proposed_title = line.split("Proposed Title:")[1].strip()
                elif line.startswith("Proposed Body:"):
                    # Use the index from the enumeration to get the proposed body lines.
                    proposed_body_lines = [l.strip() for l in lines[idx+1:]]
                    break
            proposed_body = "\n".join(proposed_body_lines).strip()
            # For an update action, ensure both title and body are non-empty.
            if action and action.lower() == "update":
                if not proposed_title or not proposed_body:
                    print(f"Warning: Incomplete update proposal for Issue {issue_id} (missing title or body). Skipping this proposal.")
                    continue
            modifications[issue_id] = {
                "action": action,
                "proposed_title": proposed_title,
                "proposed_body": proposed_body
            }
        elif header.startswith("New Issue:"):
            # Parse a new issue proposal block.
            proposed_title = None
            proposed_body_lines = []
            for idx, raw_line in enumerate(lines[1:], start=1):
                line = raw_line.strip()
                if line.startswith("Proposed Title:"):
                    proposed_title = line.split("Proposed Title:")[1].strip()
                elif line.startswith("Proposed Body:"):
                    proposed_body_lines = [l.strip() for l in lines[idx+1:]]
                    break
            proposed_body = "\n".join(proposed_body_lines).strip()
            # For new issues, both title and body are required.
            if not proposed_title or not proposed_body:
                print("Warning: Incomplete new issue proposal (missing title or body). Skipping this new issue proposal.")
            else:
                new_proposals.append({
                    "proposed_title": proposed_title,
                    "proposed_body": proposed_body
                })
    return modifications, new_proposals

def generate_proposals_with_feedback(user_feedback, issues):
    """
    Given the user feedback and a list of current Issue objects, generate feedback proposals
    using the LLM. The LLM is instructed to, for each existing issue, propose an action (Update or Delete)
    and to suggest new issues if needed.
    
    The context passed to the LLM consists solely of the current state (titles & bodies) of the issues.
    
    Returns the tuple (modifications, new_proposals) parsed from the LLM output.
    """
    # Build context from current issues (only current state)
    current_issues_context = "\n".join(
        f"Issue {issue.issue_id}:\nTitle: {issue.issue_title}\nBody: {issue.issue_body}\n"
        for issue in issues
    )
    
    prompt = f"""
You are an experienced project management assistant. The following are the current issues for a project and some user feedback.
Based solely on the current details of each issue and the user feedback, please propose for each issue one of the following actions:
  - Update: Propose a new title and a revised description.
  - Delete: Recommend that the issue be removed.
Additionally, if you think an issue is missing, provide a proposal to add a new issue.

Please provide your proposals in the following format:

For existing issues:
Issue <ID>:
Action: <Update or Delete>
If Action is Update, then include:
Proposed Title: <revised title>
Proposed Body:
<revised description>

For new issues, provide separate blocks as follows:
New Issue:
Proposed Title: <title>
Proposed Body:
<description>

User Feedback:
\"\"\"{user_feedback}\"\"\"

Current Issues:
\"\"\"{current_issues_context}\"\"\"

Important: Ensure that for every proposal, both the Proposed Title and Proposed Body are non-empty, relevant, and useful for breaking down the epic into actionable issues.

Please generate proposals for all existing issues and for any new issues required.
"""
    response = client.chat.completions.create(model="gpt-4o",
        messages=[
            {"role": "system", "content": "You are an experienced project management assistant."},
            {"role": "user", "content": prompt},
        ],
        temperature=0.7
    )
    proposals_text = response.choices[0].message.content
    modifications, new_proposals = parse_proposals(proposals_text)
    
    # For issues with an update action, store the proposed state.
    for issue in issues:
        if issue.issue_id in modifications:
            mod = modifications[issue.issue_id]
            if mod.get("action", "").lower() == "update":
                issue.proposed_issue_title = mod.get("proposed_title")
                issue.proposed_issue_body = mod.get("proposed_body")
            # If the LLM recommends deletion, we leave the proposed states as None.
    return modifications, new_proposals

def apply_proposals(issues, modifications, new_proposals, accepted_existing_ids, accepted_deletions, accepted_new_indices):
    """
    Apply the accepted proposals to the in-memory store, updating the existing list of issue objects.
    Args:
      issues: list of current Issue objects.
      modifications: dict mapping existing issue IDs to their proposal dict.
      new_proposals: list of proposals for new issues.
      accepted_existing_ids: list of issue IDs for which the proposed update should be applied.
      accepted_deletions: list of issue IDs for which deletion was accepted.
      accepted_new_indices: list of indices for new issue proposals (from new_proposals) that are accepted.
      
    For each accepted update, the current state of the issue is updated with the proposed changes.
    For each accepted deletion, the issue is removed.
    For each accepted new proposal, a new Issue is created with a new issue_id and added to the store.
    
    Returns the list of all current issues after applying the accepted proposals.
    """
    # Apply in-place updates for existing issues.
    for issue in issues:
        if issue.issue_id in accepted_existing_ids and modifications.get(issue.issue_id, {}).get("action", "").lower() == "update":
            mod = modifications[issue.issue_id]
            issue.issue_title = mod.get("proposed_title", issue.issue_title)
            issue.issue_body = mod.get("proposed_body", issue.issue_body)
            issue.proposed_issue_title = None
            issue.proposed_issue_body = None

    # Remove issues marked for deletion from the original list.
    issues[:] = [issue for issue in issues if issue.issue_id not in accepted_deletions]

    # Add new issues to the existing list.
    # Compute a new issue id starting with the max id of current issues.
    max_id = max((issue.issue_id for issue in issues), default=0)
    for idx in accepted_new_indices:
        try:
            proposal = new_proposals[idx]
        except IndexError:
            continue
        max_id += 1
        new_issue = Issue(max_id, proposal.get("proposed_title"), proposal.get("proposed_body"))
        issues.append(new_issue)
    
    # Return the in-place updated list of all current issues.
    return issues

if __name__ == "__main__":
    # Step 1: Parse initial generated issues (simulate LLM output from a previous step)
    generated_output = """
Issue 1: Implement user authentication
Details: Create endpoints for user login, logout, and registration using third-party OAuth.

Issue 2: Integrate third-party OAuth providers
Details: Configure the backend to support sign-in with providers like Google and Facebook.

Issue 3: Unwanted Issue
Details: This issue should be removed as it is not actionable.
"""
    issues = parse_generated_issues(generated_output)
    print("Initial Issues:")
    for issue in issues:
        print(issue)
    
    # Step 2: User provides feedback
    user_feedback = (
        "The issues are too generic. For Issue 1, focus specifically on backend authentication logic. "
        "For Issue 2, be more explicit about configuring multiple OAuth providers. Additionally, "
        "consider adding an issue for front-end integration and perhaps remove any issue that isn't actionable. "
        "Please remove Issue 3 as it is not actionable."
    )
    
    # Generate proposals (modifications for existing issues and suggestions for new ones)
    modifications, new_proposals = generate_proposals_with_feedback(user_feedback, issues)
    
    print("\nProposals for Existing Issues:")
    for issue_id, mod in modifications.items():
        print(f"Issue {issue_id} -> Action: {mod.get('action')}")
        if mod.get("action", "").lower() == "update":
            print(f"  Proposed Title: {mod.get('proposed_title')}")
            print(f"  Proposed Body: {mod.get('proposed_body')}\n")
        elif mod.get("action", "").lower() == "delete":
            print("  Proposed deletion.\n")
    
    if new_proposals:
        print("Proposals for New Issues:")
        for i, np in enumerate(new_proposals):
            print(f"New Issue Proposal {i}:")
            print(f"  Proposed Title: {np.get('proposed_title')}")
            print(f"  Proposed Body: {np.get('proposed_body')}\n")
    
    # Step 3: Simulate user decision on proposals.
    # Accept update for Issue 1, reject changes for Issue 2, and accept deletion for Issue 3.
    accepted_existing_ids = [1]      # Accept update for Issue 1.
    accepted_deletions = [3]         # Accept deletion for Issue 3.
    # Do not accept updates or deletions for Issue 2.
    
    accepted_new_indices = []       # Reject all new issue proposals.
    
    # Apply the accepted decisions to update the in-memory store.
    updated_issues = apply_proposals(issues, modifications, new_proposals,
                                     accepted_existing_ids, accepted_deletions, accepted_new_indices)
    
    print("\Issues After Feedback Updates:")
    for issue in updated_issues:
        print(issue) 